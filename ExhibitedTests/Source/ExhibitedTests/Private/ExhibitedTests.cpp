// Copyright 1998-2019 Epic Games, Inc. All Rights Reserved.

#include "ExhibitedTests.h"
#include "Modules/ModuleManager.h"

#include "Misc/AutomationTest.h"
#include "Tests/AutomationCommon.h"

#include "Misc/FileHelper.h"
#include "Misc/Paths.h"
#include "AssetRegistryModule.h"
#include "Containers/Array.h"
#include "Engine/Blueprint.h"

//IMPLEMENT_MODULE(FDefaultModuleImpl, ExhibitedTests)
IMPLEMENT_MODULE(FExhibitedTestsModule, ExhibitedTests);

DEFINE_LOG_CATEGORY(LogUnitTest)

DEFINE_LOG_CATEGORY(LogUnitTestDebug)

IMPLEMENT_SIMPLE_AUTOMATION_TEST(FNamingConventionTest, "ExhibitedTests.NamingConvention", EAutomationTestFlags::EditorContext | EAutomationTestFlags::EngineFilter | EAutomationTestFlags::CommandletContext);

#define LOCTEXT_NAMESPACE "FExhibitedTestsModule"

void FExhibitedTestsModule::StartupModule()
{
	// This code will execute after your module is loaded into memory; the exact timing is specified in the .uplugin file per-module
}

void FExhibitedTestsModule::ShutdownModule()
{
	// This function may be called during shutdown to clean up your module.  For modules that support dynamic reloading,
	// we call this function before unloading the module.
}

#undef LOCTEXT_NAMESPACE

bool HandleEdgeCases(FString a_assetName, FString a_assetClass, TArray<FString>& a_edgeCases)
{
	// EdgeCases can be a prefix or a classname

	for (auto edgeCase : a_edgeCases)
	{
		if (a_assetName.Contains(edgeCase) || a_assetClass.Contains(edgeCase))
		{
			return true;
		}
	}

	return false;
}

FString EnumToString(const TCHAR * Enum, int32 EnumValue)
{
	const UEnum* EnumPtr = FindObject<UEnum>(ANY_PACKAGE, Enum, true);
	if (!EnumPtr)
		return NSLOCTEXT("Invalid", "Invalid", "Invalid").ToString();

	return EnumPtr->GetNameStringByValue(EnumValue);
}

bool HasSpecialParent(UBlueprint* a_blueprint, FString* a_name, TArray<FString> &a_namingConventions)
{
	//Get parent blueprint
	UClass* parentClass = a_blueprint->ParentClass.Get();

	// Check if the parentClass actually returned anything, otherwise we are missing specifications
	if (!parentClass)
	{
		UE_LOG(LogUnitTestDebug, Warning, TEXT("%s is an unspecified native class"), *a_blueprint->GetName());
		return false;
	}

	// Get the name of the parent and check if this is specified in the naming conventions
	FString parentName = parentClass->GetName();

	for (auto convention : a_namingConventions)
	{
		// If the name is specified, rename the realClassName to the parentname - as we consider this as the type of asset
		if (convention.StartsWith(parentName))
		{
			*a_name = parentName;

			return true;
		}
	}

	// If the parent didn't exist in the specifications, it might be a child of a child so we dive in one deeper
	UBlueprint* parentBlueprint = Cast<UBlueprint>(parentClass->ClassGeneratedBy);

	if (!parentBlueprint)
	{
		UE_LOG(LogUnitTestDebug, Warning, TEXT("%s is not Generated by anything"), *parentClass->GetName());
		return false;
	}

	return HasSpecialParent(parentBlueprint, a_name, a_namingConventions);
}


FString GetRealClassName(FAssetData* assetData, TArray<FString> &a_namingConventions)
{
	FString assetClass = assetData->AssetClass.ToString();

	// Different classes are specified as Blueprint, need to find the correct one
	if (assetClass == "Blueprint")
	{
		UObject* object = assetData->GetAsset();
		UBlueprint* blueprint = Cast<UBlueprint>(object);
		FString name = EnumToString(TEXT("EBlueprintType"), blueprint->BlueprintType);

		name = name.RightChop(7); //Chop off BPTYPE_ prefix

		if (name == "Normal")
		{
			if(!HasSpecialParent(blueprint, &name, a_namingConventions))
			{
				name = "Blueprint";
			}
		}

		return name;
	}
	else if (assetClass.StartsWith("Curve"))
	{
		return "Curve";
	}

	return assetData->AssetClass.ToString();
}

bool FNamingConventionTest::RunTest(const FString& Parameters)
{

	TArray<FString> namingConventions;
	FString Dir = FPaths::ProjectPluginsDir() + "ExhibitedTests/Resources/";
	FString FullDir = Dir + "PrefixSpecifications.csv";

	// Load the naming specifications
	if (!FFileHelper::LoadFileToStringArray(namingConventions, *FullDir))
	{
		UE_LOG(LogUnitTestDebug, Error, TEXT("%s - Could not be Loaded"), *FullDir);
		return false;
	}

	TArray<FString> edgeCases;
	FullDir = Dir + "EdgeCases.txt";

	// Load the edge cases
	if (!FFileHelper::LoadFileToStringArray(edgeCases, *FullDir))
	{
		UE_LOG(LogUnitTestDebug, Error, TEXT("%s - Could not be Loaded"), *FullDir);
		return false;
	}

	// Get the AssetRegistery
	FAssetRegistryModule& AssetRegistryModule = FModuleManager::LoadModuleChecked<FAssetRegistryModule>(FName("AssetRegistry"));
	IAssetRegistry& AssetRegistry = AssetRegistryModule.Get();

	// Get all assets in our project
	TArray<FAssetData> AssetData;
	AssetRegistry.GetAssetsByPath("/Game/", AssetData, true);

	bool success = true;

	TArray<FString> testOutput;

	// Loop through all the assets
	for (auto asset : AssetData)
	{
		bool found = false;

		// Get the asset its name as specified in the naming convention
		FString assetClass = GetRealClassName(&asset, namingConventions);

		// Loop through all the specifications
		for (auto convention : namingConventions)
		{
			FString conventionName, correctPrefix;

			convention.Split("\t", &conventionName, &correctPrefix);

			// In case it doesnt see if it has a prefix or name that should be excluded
			if (HandleEdgeCases(asset.AssetName.ToString(), assetClass, edgeCases))
			{
				found = true;
				break;
			}

			// Does this convention line start with the asset its name
			if (assetClass.Equals(conventionName, ESearchCase::IgnoreCase))
			{

				// See if the name of the asset starts with the prefix that it should
				if (!asset.AssetName.ToString().StartsWith(correctPrefix, ESearchCase::CaseSensitive))
				{


					// Log that explains the error, also recorded in the test output
					UE_LOG(LogUnitTest, Error, TEXT("%s is wrongly prefixed - Prefix should be %s "), *asset.ObjectPath.ToString(), *correctPrefix);

					// Construct formatted output
					FString outputString = asset.ObjectPath.ToString();
					outputString.RemoveFromStart("/Game/");
					outputString.RemoveFromEnd("." + asset.AssetName.ToString());
					outputString.Append(".uasset," + correctPrefix);

					testOutput.Add(outputString);

					success = false;
				}

				found = true;

				break;
			}
		}
		
		// If the assetClass does not appear in the prefix specifications we should notify the user
		if (!found)
		{
			UE_LOG(LogUnitTest, Error, TEXT("The %s class does not have a specified naming convention"), *assetClass);
			success = false;
		}

	}

	if (testOutput.Num() == 0)
	{
		testOutput.Add("");
	}

	// Actually export the outputs of our test
	Dir = FPaths::ProjectDir() + "../Scripts/PrefixCheckOutput.txt";
	FFileHelper::SaveStringArrayToFile(testOutput, *Dir, FFileHelper::EEncodingOptions::ForceUTF8);
	
	return success;
}